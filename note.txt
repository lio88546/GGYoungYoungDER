-----------------------------
 山賊烤雞腿 95 塊
-------
∣ 標題 ∣
-------

<通常是任一可代換的自訂名稱>

//於程式中的描述註解

-----------------------------

--------------------
∣ Iterator（遍历器） ∣
--------------------
做為一種接口，為各種不同的數據結構提供統一的訪問機制
任一種數據結構，只要部屬該接口，就能完成遍歷操作

Iterator作用有三個
1.為各種數據結構，提供一個統一的、方便的訪問接口
2.使得數據結構的成員能夠按某種次序排列
3.提供給ES6所做的"for of"循環使用

遍歷過程(方式)
1.創建一個指針對象，指向現在數據的起始位置
2.第一次調用next方法，指針會指向第一個成員
2.第二次調用next方法，指針會指向第二個成員
3.不斷調用next方法，指針就不斷的指向下一個成員，直至他指向數據結構的結尾
每一次調用，都會返回value(成員值)與done(是否結束)兩個屬性，done是一個bool值

幹幹幹幹幹幹幹幹幹幹幹幹幹幹幹幹幹幹幹幹幹幹幹幹幹幹幹


原生有Iterator接口的數據
Array
Map
Set
String
TypedArray
函数的 arguments 对象
NodeList 对象

==============================================================================================
---------
∣ for of ∣
---------
與for in相似，但取出的部分為成員值
原生具Iterator接口的數據都能使用for of

用法
for(值 of 可循環對象){
  //處理
}
示例
---------------------------------------
let arr = [10, 20, 30]

for(let value of arr){
  console.log(value);  // 10, 20, 30
}
---------------------------------------

Object無法直接使用for of，但可以調用Object.keys()方法
按照Object的屬性進行循環
示例
------------------------------------------------
for (var key of Object.keys(someObject)) {
  console.log(key + ": " + someObject[key]);
}
------------------------------------------------
==============================================================================================

------
∣ Set ∣
------
類似數組，但他的value(值)是唯一的，不會重複

示例
----------------------------------------------
//new一個set類型的s變數
const s = new Set();

//將有重複的數組，以add方法遍歷加入s
[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));

for (let i of s) {
  console.log(i);//印出
}
//輸出結果 => 2 3 5 4
-----------------------------------------------

對set加入值時，並不會對加入的值做型別轉換，所以像是5(float)跟"5"(string)會被視為兩個不同的值
set使用的比較方式使用"類似"於===，但與===仍有區別
區別點在於，在做兩個Nan比較時，===會認為不相等，但是set會認為相等，而不做重複加入

可使用方法
add(value)：添加某个值，返回 Set 结构本身。
delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
has(value)：返回一个布尔值，表示该值是否为Set的成员。
clear()：清除所有成员，没有返回值。

遍歷方法
keys()：返回键名的遍历器
values()：返回键值的遍历器
entries()：返回键值对的遍历器
forEach()：使用回调函数遍历每个成员
Set的鍵名與鍵值相同，所以keys()與values()其實會是相同的

Array.from能將set結構轉為數組，可應用於去除重複值
示例
-------------------------------------
//去重複方法
function dedupe(array) {
  //將傳入值array轉為Set結構，再轉回數組
  return Array.from(new Set(array));
}
console.log( dedupe([1, 1, 2, 3]) );//得到 [1, 2, 3]
-------------------------------------

==============================================================================================

------
∣ Map ∣
------
與object相似，但在鍵的使用上，比object更靈活
object為 "字串-值"的方式去建立鍵值對  
Map接受 "值-值" 的方式建立鍵值對，鍵的部分，接受各類型的值(包括對象)




==============================================================================================

----------
∣ Promise ∣
----------
promise實例創建會"立即執行"
-----------------------------------------------------------
//可以用變數實例化使用
const <promise> = new Promise(function(resolve, reject) {
  // ... some code
  if ( //异步操作成功 ){
    resolve(value);
  } else {
    reject(error);
  }
});
-----------------------------------------------------------
//可置於function中，以return方式調用
function <functionName>() {
  return new Promise((resolve, reject) => {
    // ... some code
    if ( //异步操作成功 ){
      resolve(value);
    } else {
      reject(error);
    }
  });
}
-----------------------------------------------------------
並非一定要用if else方式調用resolve與reject
處理後認定為成功的，就調用resolve回調
處理後認定為拒絕的，就調用reject回調

promise狀態明確分為兩種
pending(未完成) → resolved(已成功)
pending(未完成) → rejected(已拒絕)
實例化調用後，不是"成功"就是"拒絕"狀態

调用resolve或reject並不會結束 Promise 的参数函数的執行
故調用resolve或reject時，要結束處理，會在前面加上return

回調函數調用方式 ↓
----------------------------------------------------------- 
//只用then
<functionName>.then(
  function(value){
    //resolve(成功)回調
},function(error){
    //rejecte(拒絕)回調
    //可選，端看於rejected時是否要處理
});
-----------------------------------------------------------
//用then與catch
<functionName>()
.then(function(value){
  //resolve(成功)回調
})
.catch(function(error){
  //reject(拒絕)回調
  //可選，端看於rejected時是否要處理
})
-----------------------------------------------------------
回調函數會在"所有同步任務執行完"，才會被執行

==============================================================================================

---------------
∣ Array.from() ∣
---------------
此方法會從類陣列（array-like）或是可迭代（iterable）物件建立一個 "新的" Array 實體
可以做為轉換，取得另一個array實體

參數
arrayLike 
  要被轉換至陣列的物件
  必須是類陣列（array-like）或是可迭代（iterable）物件
mapFn (option)
  Map 函式走訪陣列中的每一個元素。
thisArg (option)
  mapFn 函式執行時的 this 對象。

使用方式
Array.from(arrayLike, (選擇性)mapFn或thisArg )

Array.from() 有個可選用的參數 mapFn，它允許你在建立出新的陣列實體之後，
可以接著對陣列（或是其子類別物件）中的每一個元素執行 map 函式。
更清楚地說， Array.from(obj, mapFn, thisArg) 跟 
Array.from(obj).map(mapFn, thisArg) 的結果是一樣的，

EX:
從字串產生陣列
--------------------------------
Array.from('foo'); 
// ["f", "o", "o"]
--------------------------------

從集合產生陣列
--------------------------------
var s = new Set(['foo', window]); 
Array.from(s); 
// ["foo", window]
--------------------------------

從類陣列物件（arguments）產生陣列
--------------------------------
function f() {
  return Array.from(arguments);
}

f(1, 2, 3);

// [1, 2, 3]
--------------------------------

使用箭頭函式及 Array.from
--------------------------------
// 使用箭頭函式作為 map 函式來
// 操作元素
Array.from([1, 2, 3], x => x + x);      
// [2, 4, 6]

// 產生數值序列
// 因為陣列中的每個位置都會被初始化為 `undefined`，
// 下方 `v` 會是 `undefined`
Array.from({length: 5}, (v, i) => i);
// [0, 1, 2, 3, 4]
--------------------------------

==============================================================================================

----------
∣ async() ∣
----------





